#!/bin/bash
# This script is released under the GNU General Public License 3.0
# Check the COPYING file included with this distribution

## start by exiting if the user doesn't have enough RAM for the install to work

ANSWER="/tmp/.setup"
readonly SHAREDIR="$(dirname ${0})/../share/pentoo-installer"
EDITOR=
PARTITIONEDITOR=
isnumber='^[0-9]+$'

# source common variables, functions and error handling
source "${SHAREDIR}"/common.sh || exit $?

# clock
HARDWARECLOCK=
TIMEZONE=

# partitions
PART_ROOT=

# default filesystem specs (the + is bootable flag)
# <mountpoint>:<partsize>:<fstype>[:+]
DEFAULTFS="/boot:64:ext2:+ swap:4096:swap /:*:ext4"

# install stages
S_CLOCK=0       # clock and timezone
S_PART=0        # partitioning
S_MKFS=0        # formatting
S_MKFSAUTO=0    # auto fs part/formatting TODO: kill this
S_CONFIG=0      # configuration editing
S_GRUB=0        # TODO: kill this - if using grub
S_BOOT=""       # bootloader installed (set to loader name instead of 1)
S_FDE=0         # Full disk encryption, need key in /boot

# main menu selection tracker
CURRENT_SELECTION=""

#let's support Xdialog for the fun of it
if [ -x "$(command -v Xdialog 2>&1)" ]; then
    if [ -z "${DISPLAY}" ]; then
        whichdialog=dialog
    else
        whichdialog=Xdialog
    fi
else
    whichdialog=dialog
fi
#yes, we purposely don't handle dialog being missed, deps handle it

# DIALOG()
# an el-cheapo dialog wrapper
#
# parameters: see dialog(1)
# returns: whatever dialog did
DIALOG() {
    ${whichdialog} --backtitle "$TITLE" --aspect 15 "$@"
    return $?
}

# gen_key()
# Generate a key, optionnaly encrypt it with gpg
# $1 use gpg or not
# $2 gpg key to store
#
gen_key()
{
    if [ ${1} = "yes" ]; then
        DIALOG --msgbox "We will now generate a GPG-encrypted luks key for `basename ${2}`" 0 0
        head -c60 /dev/urandom | base64 | head -n1 | tr -d '\n' > "${2}"
        gpg --symmetric --cipher-algo aes256 --armor "${2}"
    else
        head -c60 /dev/urandom | base64 | head -n1 | tr -d '\n' > "${2}"
    fi
}

# luks_fmt()
# format a luks partition. Cipher and hash chosen arbitrarily
# $1 use GPG
# $2 device to luksformat
# $3 key
#
luks_fmt()
{
    if [ ${1} = "yes" ]; then
        DIALOG --msgbox "Please enter the GPG key for `basename ${3/.asc/}`" 0 0
        gpg --decrypt "${3}" | cryptsetup -h sha512 -c aes-xts-plain64 -s 512 luksFormat --align-payload=8192 "${2}"
    else
        cat "${3}" | cryptsetup -h sha512 -c aes-xts-plain64 -s 512 luksFormat --align-payload=8192 "${2}"
    fi
}

# luks_open()
# open a luks partition
# $1 use GPG
# $2 device to luksformat
# $3 gpg key
# $4 name of new device
#
luks_open()
{
    if [ ${1} = "yes" ]; then
        DIALOG --msgbox "Please enter the GPG key for `basename ${3/.asc/}` (last time :-)" 0 0
        gpg --decrypt "${3}" | cryptsetup luksOpen "${2}" "${4}"
    else
        cat "${3}" | cryptsetup luksOpen "${2}" "${4}"
    fi
}

# chroot_mount()
# prepares target system as a chroot
#
chroot_mount()
{
    [ -e "${DESTDIR}/sys" ] || mkdir "${DESTDIR}/sys"
    [ -e "${DESTDIR}/proc" ] || mkdir "${DESTDIR}/proc"
    [ -e "${DESTDIR}/dev" ] || mkdir "${DESTDIR}/dev"
    mount -t sysfs sysfs "${DESTDIR}/sys"
    mount -t proc proc "${DESTDIR}/proc"
    mount -o bind /dev "${DESTDIR}/dev"
}

# chroot_umount()
# tears down chroot in target system
#
chroot_umount()
{
    sleep 1
    umount $DESTDIR/proc
    umount $DESTDIR/sys
    umount $DESTDIR/dev
}

finddisks() {
    workdir="$PWD"
    cd /sys/block
    # ide devices
    for dev in $(ls | egrep '^hd'); do
        if [ "$(cat $dev/device/media)" = "disk" ]; then
            echo "/dev/$dev"
            [ "$1" ] && echo $1
        fi
    done
    #scsi/sata devices
    for dev in $(ls | egrep '^sd'); do
        # TODO: what is the significance of 5?
        if ! [ "$(cat $dev/device/type)" = "5" ]; then
            echo "/dev/$dev"
            [ "$1" ] && echo $1
        fi
    done
    #virtual devices
    for dev in $(ls | egrep '^vd'); do
        # TODO: how to check if this is really a disk?
        if [ "$(grep -c 'DEVTYPE=disk' $dev/uevent)" = "1" ]; then
            echo "/dev/$dev"
            [ "$1" ] && echo $1
        fi
    done
    # cciss controllers
    if [ -d /dev/cciss ] ; then
        cd /dev/cciss
        for dev in $(ls | egrep -v 'p'); do
            echo "/dev/cciss/$dev"
            [ "$1" ] && echo $1
        done
    fi
    # Smart 2 controllers
    if [ -d /dev/ida ] ; then
        cd /dev/ida
        for dev in $(ls | egrep -v 'p'); do
            echo "/dev/ida/$dev"
            [ "$1" ] && echo $1
        done
    fi
    cd "$workdir"
}

# getuuid()
# converts /dev/[hs]d?[0-9] devices to UUIDs
#
# parameters: device file
# outputs:    UUID on success
#             nothing on failure
# returns:    nothing
getuuid()
{
    if [ "${1%%/[hs]d?[0-9]}" != "${1}" ]; then
        echo "$(blkid -s UUID -o value ${1})"
    fi
}

# getkernelversion()
# outputs the kernel version
#
# parameters: none
# outputs:    kernel version on success
#             nothing on failure
# returns:    0 on success
#             1 on failure
getkernelversion()
{
    local kernver=$(ls $DESTDIR/boot/kernel-genkernel-* |sed -e "s|kernel-genkernel||g" -e "s|$DESTDIR/boot/||") \
        || return 1
    echo "${kernver}"
}

findpartitions() {
    workdir="$PWD"
    for devpath in $(finddisks); do
        disk=$(echo $devpath | sed 's|.*/||')
        cd /sys/block/$disk
        for part in $disk*; do
            # check if not already assembled to a raid device
            if ! [ "$(cat /proc/mdstat 2>/dev/null | grep $part)" -o "$(fstype 2>/dev/null </dev/$part | grep "lvm2")" -o "$(sfdisk -c /dev/$disk $(echo $part | sed -e "s#$disk##g") 2>/dev/null | grep "5")" ]; then
                if [ -d $part ]; then
                    echo "/dev/$part"
                    [ "$1" ] && echo $1
                fi
            fi
        done
    done
    # include any mapped devices
    for devpath in $(ls /dev/mapper 2>/dev/null | grep -v control); do
        echo "/dev/mapper/$devpath"
        [ "$1" ] && echo $1
    done
    # include any raid md devices
    for devpath in $(ls -d /dev/md* | grep '[0-9]' 2>/dev/null); do
        if cat /proc/mdstat | grep -qw $(echo $devpath | sed -e 's|/dev/||g'); then
        echo "$devpath"
        [ "$1" ] && echo $1
        fi
    done
    # inlcude cciss controllers
    if [ -d /dev/cciss ] ; then
        cd /dev/cciss
        for dev in $(ls | egrep 'p'); do
            echo "/dev/cciss/$dev"
            [ "$1" ] && echo $1
        done
    fi
    # inlcude Smart 2 controllers
    if [ -d /dev/ida ] ; then
        cd /dev/ida
        for dev in $(ls | egrep 'p'); do
            echo "/dev/ida/$dev"
            [ "$1" ] && echo $1
        done
    fi
    cd "$workdir"
}

get_grub_map() {
    [ -e /tmp/dev.map ] && rm /tmp/dev.map
    DIALOG --infobox "Generating GRUB device map...\nThis could take a while.\n\n Please be patient." 0 0
    $DESTDIR/sbin/grub --no-floppy --device-map /tmp/dev.map >/tmp/grub.log 2>&1 <<EOF
quit
EOF
}

mapdev() {
    partition_flag=0
    device_found=0
    devs=$(cat /tmp/dev.map | grep -v fd | sed 's/ *\t/ /' | sed ':a;$!N;$!ba;s/\n/ /g')
    linuxdevice=$(echo $1 | cut -b1-8)
    if [ "$(echo $1 | egrep '[0-9]$')" ]; then
        # /dev/hdXY
        pnum=$(echo $1 | cut -b9-)
        pnum=$(($pnum-1))
        partition_flag=1
    fi
    for  dev in $devs
    do
        if [ "(" = $(echo $dev | cut -b1) ]; then
        grubdevice="$dev"
        else
        if [ "$dev" = "$linuxdevice" ]; then
            device_found=1
            break
        fi
       fi
    done
    if [ "$device_found" = "1" ]; then
        if [ "$partition_flag" = "0" ]; then
            echo "$grubdevice"
        else
            grubdevice_stringlen=${#grubdevice}
            grubdevice_stringlen=$(($grubdevice_stringlen - 1))
            grubdevice=$(echo $grubdevice | cut -b1-$grubdevice_stringlen)
            echo "$grubdevice,$pnum)"
        fi
    else
        echo "DEVICE NOT FOUND"
    fi
}

printk()
{
    case $1 in
        "on")  echo 4 >/proc/sys/kernel/printk ;;
        "off") echo 0 >/proc/sys/kernel/printk ;;
    esac
}

# seteditor()
# prompts the user to choose an editor
# sets EDITOR global variable
#
seteditor() {
    chroot_mount
    DIALOG --menu "Select a Text Editor to Use" 10 35 3 \
        "1" "nano (easier)" \
        "2" "vi" \
        "3" "mcedit" 2>$ANSWER
    case $(cat $ANSWER) in
        "1") EDITOR="nano"
             eselect editor set /bin/nano
             source /etc/profile
             chroot $DESTDIR /bin/bash <<EOF
eselect editor set /bin/nano
source /etc/profile
EOF
             ;;
        "2") EDITOR="vi"
#             sed -i 's#/bin/nano#/usr/bin/vi#' ${DISTDIR}/etc/profile
             eselect editor set /usr/bin/vi
             source /etc/profile
             chroot $DESTDIR /bin/bash <<EOF
eselect editor set /usr/bin/vi
source /etc/profile
EOF
             ;;
        "3") EDITOR="mcedit"
             eselect editor set /usr/bin/mcedit
             source /etc/profile
             chroot $DESTDIR /bin/bash <<EOF
eselect editor set /usr/bin/mcedit
source /etc/profile
EOF
             ;;
        *)   EDITOR="nano" ;;
    esac
    chroot_umount
}

# setpartitionlabel()
# select and write partition layout
# parameters: device
# sets PARTITIONEDITOR global variable
#
setpartitionlabel() {
    while true; do
        local pt=
        DIALOG --menu "Select a Partition Table to Use" 10 35 3 \
            "1" "msdos (default)" \
            "2" "gpt (unsupported)" 2>$ANSWER
        [ "${ANSWER}" = "" ] && pt='msdos'
        case "$(cat $ANSWER)" in
            "1")
                PARTITIONEDITOR="cfdisk"
                pt='msdos' ;;
            "2")
                PARTITIONEDITOR="cgdisk"
                pt='gpt' ;;
            *) return 1 ;;
        esac
        # Check current partition layout
        local cpt=$(parted $1 print | sed -nr 's/^Partition Table:\s(.*)/\1/p')
        if [ "${pt}" != "${cpt}" ]; then
            DIALOG --defaultno --yesno "$1 will be COMPLETELY ERASED!  Are you absolutely sure?" 0 0 \
                || continue
            parted $1 mklabel "${pt}" || continue
        fi
        break
    done
}

# _mkfs()
# Create and mount filesystems in our destination system directory.
#
# args:
#  domk: Whether to make the filesystem or use what is already there
#  device: Device filesystem is on
#  fstype: type of filesystem located at the device (or what to create)
#  dest: Mounting location for the destination system
#  mountpoint: Mount point inside the destination system, e.g. '/boot'

# returns: 1 on failure
_mkfs() {
    local _domk=$1
    local _device=$2
    local _fstype=$3
    local _dest=$4
    local _mountpoint=$5
    case ${_fstype} in
        *-luks)
                if [ ${_mountpoint} = "/" ]; then
                    _luksname="root"
                    S_FDE=1
                    local _lukskey=/tmp/${_luksname}
                    gen_key yes ${_lukskey} && _lukskey=${_lukskey}.asc
                    luks_fmt yes ${_device} ${_lukskey} && luks_open yes ${_device} ${_lukskey} ${_luksname} && _device=/dev/mapper/${_luksname} && _fstype=${_fstype/-luks/}
                else
                    local _luksname=`basename $5`
                    local _lukskey=/tmp/${_luksname}
                    DIALOG --defaultno --yesno "Do you want to use GPG encrypted key for this partition ($_mountpoint) ?" 0 0 && DOGPG="YES"
                    if [ ${DOGPG} = "YES" ]; then
                        gen_key yes ${_lukskey} && _lukskey=${_lukskey}.asc
                        echo -e "target=${_luksname}\nsource='${_device}'\nkey='/etc/keys/`basename ${_lukskey}`:gpg'\n" >>/tmp/.dmcrypt
                        luks_fmt yes ${_device} ${_lukskey} && luks_open yes ${_device} ${_lukskey} ${_luksname} && _device=/dev/mapper/${_luksname} && _fstype=${_fstype/-luks/}
                    else
                        gen_key no ${_lukskey}
                        echo -e "target=${_luksname}\nsource='${_device}'\nkey='/etc/keys/`basename ${_lukskey}`'\n" >>/tmp/.dmcrypt
                        luks_fmt no ${_device} ${_lukskey} && luks_open no ${_device} ${_lukskey} ${_luksname} && _device=/dev/mapper/${_luksname} && _fstype=${_fstype/-luks/}
                    fi
                fi
                ret=$?
                if [ $ret != 0 ]; then
                    DIALOG --msgbox "Error creating luks filesystem ${_fstype} on ${_device}" 0 0
                    return 1
                fi
                ;;
    esac

    echo "$@" >> $LOG
    # we have two main cases: "swap/crypt-swap" and everything else.
    if [ "${_fstype}" = "swap" ]; then
        swapoff ${_device} >/dev/null 2>&1
        if [ "${_domk}" = "yes" ]; then
            mkswap ${_device} >>$LOG 2>&1
            if [ $? != 0 ]; then
                DIALOG --msgbox "Error creating swap: mkswap ${_device}" 0 0
                return 1
            fi
        fi
        swapon ${_device} >>$LOG 2>&1
        if [ $? != 0 ]; then
            DIALOG --msgbox "Error activating swap: swapon ${_device}" 0 0
            return 1
        fi
    elif [ "${_fstype}" = "crypt-swap" ]; then
        swapoff ${_device} >/dev/null 2>&1
        if [ "${_domk}" = "yes" ]; then
            cryptsetup create -c aes-xts-plain64:sha512 -s 512 -d /dev/urandom swap ${_device} >>$LOG 2>&1 && echo -e "swap=swap\nsource='${_device}'\n" >>/tmp/.dmcrypt && _device="/dev/mapper/swap" && mkswap ${_device} >>$LOG 2>&1 && _fstype="swap"
            if [ $? != 0 ]; then
                DIALOG --msgbox "Error creating swap: mkswap ${_device}" 0 0
                return 1
            fi

        fi
        swapon ${_device} >>$LOG 2>&1
        if [ $? != 0 ]; then
            DIALOG --msgbox "Error activating swap: swapon ${_device}" 0 0
            return 1
        fi
    else
        # make sure the fstype is one we can handle
        local knownfs=0
        for fs in btrfs xfs jfs reiserfs ext2 ext3 ext4 vfat; do
            [ "${_fstype}" = "${fs}" ] && knownfs=1 && break
        done
        if [ $knownfs -eq 0 ]; then
            DIALOG --msgbox "unknown fstype ${_fstype} for ${_device}" 0 0
            return 1
        fi
        # if we were tasked to create the filesystem, do so
        if [ "${_domk}" = "yes" ]; then
            local ret
            case ${_fstype} in
                btrfs)    mkfs.btrfs -f ${_device} >>$LOG 2>&1; ret=$? ;;
                xfs)      mkfs.xfs -f ${_device} >>$LOG 2>&1; ret=$? ;;
                jfs)      yes | mkfs.jfs ${_device} >>$LOG 2>&1; ret=$? ;;
                reiserfs) yes | mkreiserfs ${_device} >>$LOG 2>&1; ret=$? ;;
                ext2)     mke2fs "${_device}" -F >>$LOG 2>&1; ret=$? ;;
                ext3)     mke2fs -j ${_device} -F >>$LOG 2>&1; ret=$? ;;
                ext4)     mke2fs -t ext4 ${_device} -F >>$LOG 2>&1; ret=$? ;;
                vfat)     mkfs.vfat ${_device} >>$LOG 2>&1; ret=$? ;;
                # don't handle anything else here, we will error later
            esac
            if [ $ret != 0 ]; then
                DIALOG --msgbox "Error creating filesystem ${_fstype} on ${_device}" 0 0
                return 1
            fi
            sleep 2
        fi
        # create our mount directory
        mkdir -p ${_dest}${_mountpoint}
        # mount the bad boy
        mount -t ${_fstype} ${_device} ${_dest}${_mountpoint} >>$LOG 2>&1
        if [ $? != 0 ]; then
            DIALOG --msgbox "Error mounting ${_dest}${_mountpoint}" 0 0
            return 1
        fi
    fi

    # add to temp fstab
    echo -n "${_device} ${_mountpoint} ${_fstype} defaults 0 " >>/tmp/.fstab

    if [ "${_fstype}" = "swap" ]; then
        echo "0" >>/tmp/.fstab
    else
        echo "1" >>/tmp/.fstab
    fi
}

# Disable swap and all mounted partitions for the destination system. Unmount
# the destination root partition last!
_umountall()
{
    DIALOG --infobox "Disabling swapspace, unmounting already mounted disk devices..." 0 0
    swapoff -a >/dev/null 2>&1
    umount $(mount | grep -v "${DESTDIR} " | grep "${DESTDIR}" | sed 's|\ .*||g') >/dev/null 2>&1
    umount $(mount | grep "${DESTDIR} " | sed 's|\ .*||g') >/dev/null 2>&1
}

# _getdisccapacity()
#
# parameters: device file
# outputs:    disc capacity in bytes
_getdisccapacity()
{
    fdisk -l $1 2>/dev/null | sed -n '2p' | cut -d' ' -f5
}

# Get a list of available disks for use in the "Available disks" dialogs. This
# will print the disks as follows, getting size info from _getdisccapacity():
#   /dev/sda: 625000 MiB (610 GiB)
#   /dev/sdb: 476940 MiB (465 GiB)
_getavaildisks()
{
    for DISC in $(finddisks); do
        DISC_SIZE=$(_getdisccapacity $DISC)
        echo "$DISC: $((DISC_SIZE / 2**20)) MiB ($((DISC_SIZE / 2**30)) GiB)\n"
    done
}

autoprepare()
{
    DISCS=$(finddisks)
    if [ $(echo $DISCS | wc -w) -gt 1 ]; then
        DIALOG --msgbox "Available Disks:\n\n$(_getavaildisks)\n" 0 0
        DIALOG --menu "Select the hard drive to use" 14 55 7 $(finddisks _) 2>$ANSWER || return 1
        DISC=$(cat $ANSWER)
    elif [ $(echo $DISCS | wc -w) -eq 1 ]; then
        DISC=$DISCS
    else
        DIALOG --msgbox "No stuitable storage media found. Please try manual install." 0 0
        exit 1
    fi
    SET_DEFAULTFS=""
    BOOT_PART_SET=""
    SWAP_PART_SET=""
    ROOT_PART_SET=""
    CHOSEN_FS=""
    # disk size in MiB
    DISC_SIZE=$(($(_getdisccapacity $DISC) / 2**20))

    while [ "$SET_DEFAULTFS" = "" ]; do
        FSOPTS="ext2 ext2 ext3 ext3 ext3-luks ext3-luks ext4 ext4 ext4-luks ext4-luks"
        [ "$(which mkreiserfs 2>/dev/null)" ] && FSOPTS="$FSOPTS reiserfs Reiser3 reiserfs-luks Reiser3-luks"
        [ "$(which mkfs.btrfs 2>/dev/null)" ]   && FSOPTS="$FSOPTS btrfs BTRFS"
        [ "$(which mkfs.xfs 2>/dev/null)" ]   && FSOPTS="$FSOPTS xfs XFS"
        [ "$(which mkfs.jfs 2>/dev/null)" ]   && FSOPTS="$FSOPTS jfs JFS"
        while [ "$BOOT_PART_SET" = "" ]; do
            DIALOG --inputbox "Enter the size (MiB) of your /boot partition.  Minimum value is 32.\n\nDisk space left: $DISC_SIZE MiB" 10 65 "128" 2>$ANSWER || return 1
            BOOT_PART_SIZE="$(cat $ANSWER)"
            if ! [[ ${BOOT_PART_SIZE} =~ ${isnumber} ]]; then
                DIALOG --msgbox "ERROR: You have entered an invalid size, please enter again." 0 0
            else
                if [ "$BOOT_PART_SIZE" -ge "$DISC_SIZE" -o "$BOOT_PART_SIZE" -lt "32" -o "$SBOOT_PART_SIZE" = "$DISC_SIZE" ]; then
                    DIALOG --msgbox "ERROR: You have entered a too large size, please enter again." 0 0
                else
                    BOOT_PART_SET=1
                fi
            fi
        done
        DISC_SIZE=$(($DISC_SIZE-$BOOT_PART_SIZE))
        while [ "$SWAP_PART_SET" = "" ]; do
            SUGGESTED_SWAP_SIZE=$(awk '/MemTotal/ {printf( "%.0f\n", int ( $2 / 1024 ) + 1)}' /proc/meminfo)
#the line above is confusing mceditor. Close it: '

            DIALOG --inputbox "Enter the size (MiB) of your swap partition.  Minimum value is > 0.\n\nDisk space left: $DISC_SIZE MiB" 10 65 "${SUGGESTED_SWAP_SIZE}" 2>$ANSWER || return 1
            SWAP_PART_SIZE=$(cat $ANSWER)
            if ! [[ ${SWAP_PART_SIZE} =~ ${isnumber} ]] ; then
                DIALOG --msgbox "ERROR: You have entered an invalid size, please enter again." 0 0
            else
                if [ "$SWAP_PART_SIZE" -ge "$DISC_SIZE" ]; then
                    DIALOG --msgbox "ERROR: You have entered a too large size, please enter again." 0 0
                else
                    SWAP_PART_SET=1
                fi
            fi
        done
        DISC_SIZE=$(($DISC_SIZE-$SWAP_PART_SIZE))
        while [ "$ROOT_PART_SET" = "" ]; do
            if [ "${DISC_SIZE}" -lt "12000" ]; then
                DIALOG --msgbox "Pentoo requires at least 12GB for / and you don't have that much left, aborting install." 0 0
                exit 1
            elif [ "${DISC_SIZE}" -lt "24000" ]; then
                DIALOG --msgbox "Pentoo *suggests* using at least 24GB for your / partition but you don't have that much left. You have been warned." 0 0
            fi
            DIALOG --msgbox "${DISC_SIZE} MiB will be used for your / partition." 0 0 && ROOT_PART_SET=1
        done
        while [ "$CHOSEN_FS" = "" ]; do
            DIALOG --default-item "ext4" --menu "Select a filesystem for /" 13 45 6 $FSOPTS 2>$ANSWER || return 1
            FSTYPE=$(cat $ANSWER)
            DIALOG --yesno "$FSTYPE will be used for /. Is this OK?" 0 0 && CHOSEN_FS=1
        done
        SET_DEFAULTFS=1
    done

    DIALOG --defaultno --yesno "$DISC will be COMPLETELY ERASED!  Are you absolutely sure?" 0 0 \
    || return 1

    DEVICE=$DISC
    FSSPECS=$(echo $DEFAULTFS | sed -e "s|/:\*:ext4|/:$ROOT_PART_SIZE:$FSTYPE|g" -e "s|swap:4096|swap:$SWAP_PART_SIZE|g" -e "s|/boot:64|/boot:$BOOT_PART_SIZE|g")
    sfdisk_input=""

    # we assume a /dev/hdX format (or /dev/sdX)
    PART_ROOT="${DEVICE}3"

    if [ "$S_MKFS" = "1" ]; then
        DIALOG --msgbox "You have already prepared your filesystems manually" 0 0
        return 0
    fi

    # validate DEVICE
    if [ ! -b "$DEVICE" ]; then
      DIALOG --msgbox "Device '$DEVICE' is not valid" 0 0
      return 1
    fi

    # validate DEST
    if [ ! -d "$DESTDIR" ]; then
        DIALOG --msgbox "Destination directory '$DESTDIR' is not valid" 0 0
        return 1
    fi

    # / required
    if [ $(echo $FSSPECS | grep '/:' | wc -l) -ne 1 ]; then
        DIALOG --msgbox "Need exactly one root partition" 0 0
        return 1
    fi

    rm -f /tmp/.fstab
    rm -f /tmp/.dmcrypt

    _umountall

    # setup input var for sfdisk
    for fsspec in $FSSPECS; do
        fssize=$(echo $fsspec | tr -d ' ' | cut -f2 -d:)
        if [ "$fssize" = "*" ]; then
                fssize_spec=';'
        else
                fssize_spec=",$fssize"
        fi
        fstype=$(echo $fsspec | tr -d ' ' | cut -f3 -d:)
        if [ "$fstype" = "swap" ]; then
                fstype_spec=",S"
        else
                fstype_spec=","
        fi
        bootflag=$(echo $fsspec | tr -d ' ' | cut -f4 -d:)
        if [ "$bootflag" = "+" ]; then
            bootflag_spec=",*"
        else
            bootflag_spec=""
        fi
        sfdisk_input="${sfdisk_input}${fssize_spec}${fstype_spec}${bootflag_spec}\n"
    done
    sfdisk_input=$(printf "$sfdisk_input")

    # invoke sfdisk
    printk off
    DIALOG --infobox "Partitioning $DEVICE" 0 0
    sfdisk $DEVICE -uM >$LOG 2>&1 <<EOF
$sfdisk_input
EOF
    if [ $? -gt 0 ]; then
        DIALOG --msgbox "Error partitioning $DEVICE (see $LOG for details)" 0 0
        printk on
        return 1
    fi
    printk on

    # need to mount root first, then do it again for the others
    part=1
    for fsspec in $FSSPECS; do
        mountpoint=$(echo $fsspec | tr -d ' ' | cut -f1 -d:)
        fstype=$(echo $fsspec | tr -d ' ' | cut -f3 -d:)
        if echo $mountpoint | tr -d ' ' | grep '^/$' 2>&1 > /dev/null; then
            _mkfs yes ${DEVICE}${part} "$fstype" "$DESTDIR" "$mountpoint" || return 1
        fi
        part=$(($part + 1))
    done

    # make other filesystems
    part=1
    for fsspec in $FSSPECS; do
        mountpoint=$(echo $fsspec | tr -d ' ' | cut -f1 -d:)
        fstype=$(echo $fsspec | tr -d ' ' | cut -f3 -d:)
        if [ $(echo $mountpoint | tr -d ' ' | grep '^/$' | wc -l) -eq 0 ]; then
            _mkfs yes ${DEVICE}${part} "$fstype" "$DESTDIR" "$mountpoint" || return 1
        fi
        part=$(($part + 1))
    done

    DIALOG --msgbox "Auto-prepare was successful" 0 0
    S_MKFSAUTO=1
}

partition() {
    if [ "$S_MKFSAUTO" = "1" ]; then
        DIALOG --msgbox "You have already prepared your filesystems with Auto-prepare" 0 0
        return 0
    fi

    _umountall

    # Select disk to partition
    DISCS=$(finddisks _)
    DISCS="$DISCS OTHER - DONE +"
    DIALOG --msgbox "Available Disks:\n\n$(_getavaildisks)\n" 0 0
    DISC=""
    while true; do
        # Prompt the user with a list of known disks
        DIALOG --menu "Select the disk you want to partition (select DONE when finished)" 14 55 7 $DISCS 2>$ANSWER || return 1
        DISC=$(cat $ANSWER)
        if [ "$DISC" = "OTHER" ]; then
            DIALOG --inputbox "Enter the full path to the device you wish to partition" 8 65 "/dev/sda" 2>$ANSWER || return 1
            DISC=$(cat $ANSWER)
        fi
        # Leave our loop if the user is done partitioning
        [ "$DISC" = "DONE" ] && break
        # Set partition layout and partition editor PARTITIONEDITOR
        setpartitionlabel $DISC || continue
        # Partition disc
        DIALOG --msgbox "Now you'll be put into the ${PARTITIONEDITOR} program where you can partition your hard drive. You should make a swap partition and as many data partitions as you will need.  NOTE: ${PARTITIONEDITOR} may tell you to reboot after creating partitions.  If you need to reboot, just re-enter this install program, skip this step and go on to step 2." 18 70
        $PARTITIONEDITOR $DISC
    done
    S_PART=1
}

mountpoints() {
    if [ "$S_MKFSAUTO" = "1" ]; then
        DIALOG --msgbox "You have already prepared your filesystems with Auto-prepare" 0 0
        return 0
    fi
    while [ "$PARTFINISH" != "DONE" ]; do
        : >/tmp/.fstab
        : >/tmp/.dmcrypt
        : >/tmp/.parts

        # Determine which filesystems are available
        FSOPTS="ext2 ext2 ext3 ext3 ext3-luks ext3-luks ext4 ext4 ext4-luks ext4-luks"
        [ "$(which mkreiserfs 2>/dev/null)" ] && FSOPTS="$FSOPTS reiserfs Reiser3 reiserfs-luks Reiser3-luks"
        [ "$(which mkfs.btrfs 2>/dev/null)" ]   && FSOPTS="$FSOPTS btrfs BTRFS"
        [ "$(which mkfs.xfs 2>/dev/null)" ]   && FSOPTS="$FSOPTS xfs XFS"
        [ "$(which mkfs.jfs 2>/dev/null)" ]   && FSOPTS="$FSOPTS jfs JFS"
        [ "$(which mkfs.vfat 2>/dev/null)" ]  && FSOPTS="$FSOPTS vfat VFAT"

        # Select mountpoints
        DIALOG --msgbox "Available Disks:\n\n$(_getavaildisks)\n" 0 0
        PARTS=$(findpartitions _)
        DIALOG --menu "Select the partition to use as swap" 21 50 13 NONE - $PARTS 2>$ANSWER || return 1
        PART=$(cat $ANSWER)
        PARTS="$(echo $PARTS | sed -e "s#${PART}\ _##g")"
        if [ "$PART" != "NONE" ]; then
            DOMKFS="no"
            DIALOG --yesno "Would you like to create a filesystem on $PART?\n\n(This will overwrite existing data!)" 0 0 && DOMKFS="yes"
            DIALOG --yesno "Would you like to encrypt the swap partition?" 0 0 && CRYPTSWAP="yes"
            if [ "$CRYPTSWAP" = "yes" ]; then
                echo "$PART:crypt-swap:swap:$DOMKFS" >>/tmp/.parts
            else
                echo "$PART:swap:swap:$DOMKFS" >>/tmp/.parts
            fi
        fi

        DIALOG --menu "Select the partition to mount as /" 21 50 13 $PARTS 2>$ANSWER || return 1
        PART=$(cat $ANSWER)
        PARTS="$(echo $PARTS | sed -e "s#${PART}\ _##g")"
        PART_ROOT=$PART
        # Select root filesystem type
        DIALOG --menu "Select a filesystem for $PART" 13 45 6 $FSOPTS 2>$ANSWER || return 1
        FSTYPE=$(cat $ANSWER)
        DOMKFS="no"
        DIALOG --yesno "Would you like to create a filesystem on $PART?\n\n(This will overwrite existing data!)" 0 0 && DOMKFS="yes"
        echo "$PART:$FSTYPE:/:$DOMKFS" >>/tmp/.parts

        #
        # Additional partitions
        #
        DIALOG --menu "Select any additional partitions to mount under your new root (select DONE when finished)" 21 50 13 $PARTS DONE _ 2>$ANSWER || return 1
        PART=$(cat $ANSWER)
        while [ "$PART" != "DONE" ]; do
            PARTS="$(echo $PARTS | sed -e "s#${PART}\ _##g")"
            # Select a filesystem type
            DIALOG --menu "Select a filesystem for $PART" 13 45 6 $FSOPTS 2>$ANSWER || return 1
            FSTYPE=$(cat $ANSWER)
            MP=""
            while [ "${MP}" = "" ]; do
                DIALOG --inputbox "Enter the mountpoint for $PART" 8 65 "/boot" 2>$ANSWER || return 1
                MP=$(cat $ANSWER)
                if grep ":$MP:" /tmp/.parts; then
                    DIALOG --msgbox "ERROR: You have defined 2 identical mountpoints! Please select another mountpoint." 8 65
                    MP=""
                fi
            done
            DOMKFS="no"
            DIALOG --yesno "Would you like to create a filesystem on $PART?\n\n(This will overwrite existing data!)" 0 0 && DOMKFS="yes"
            echo "$PART:$FSTYPE:$MP:$DOMKFS" >>/tmp/.parts
            DIALOG --menu "Select any additional partitions to mount under your new root" 21 50 13 $PARTS DONE _ 2>$ANSWER || return 1
            PART=$(cat $ANSWER)
        done
        DIALOG --yesno "Would you like to create and mount the filesytems like this?\n\nSyntax\n------\nDEVICE:TYPE:MOUNTPOINT:FORMAT\n\n$(for i in $(cat /tmp/.parts); do echo "$i\n";done)" 18 0 && PARTFINISH="DONE"
    done

    _umountall

    for line in $(cat /tmp/.parts); do
        PART=$(echo $line | cut -d: -f 1)
        FSTYPE=$(echo $line | cut -d: -f 2)
        MP=$(echo $line | cut -d: -f 3)
        DOMKFS=$(echo $line | cut -d: -f 4)
        umount ${DESTDIR}${MP}
        if [ "$DOMKFS" = "yes" ]; then
            if [ "$FSTYPE" = "swap" ]; then
                DIALOG --infobox "Creating and activating swapspace on $PART" 0 0
            else
                DIALOG --infobox "Creating $FSTYPE on $PART, mounting to ${DESTDIR}${MP}" 0 0
            fi
            _mkfs yes $PART $FSTYPE $DESTDIR $MP || return 1
        else
            if [ "$FSTYPE" = "swap" ]; then
                DIALOG --infobox "Activating swapspace on $PART" 0 0
            else
                DIALOG --infobox "Mounting $PART to ${DESTDIR}${MP}" 0 0
            fi
            _mkfs no $PART $FSTYPE $DESTDIR $MP || return 1
        fi
        sleep 1
    done

    DIALOG --msgbox "Partitions were successfully mounted." 0 0
    S_MKFS=1
}

# run_unsquashfs()
# runs unsquashfs on the target system, displays output
# $1 : source
# $2 : dest
# $3 : msg
# taken from manjaro
run_unsquashfs()
{
    # all unsquashfs output goes to /tmp/unsquashfs.log, which we tail
    # into a dialog
    touch /tmp/setup-unsquashfs-running
    #set the return code to failure so if things race we catch the failure
    echo 1 > /tmp/.unsquashfs-retcode
    ( \
        echo "unsquashing $(basename $1)..." > /tmp/unsquashfs.log; \
        echo >> /tmp/unsquashfs.log; \
        unsquashfs -f -d $2 $1 >>/tmp/unsquashfs.log 2>&1
        echo $? > /tmp/.unsquashfs-retcode
        echo >> /tmp/unsquashfs.log
        rm -f /tmp/setup-unsquashfs-running
    ) &
sleep 1
( \
c=0
while [ -e /tmp/setup-unsquashfs-running ]
    do
        sleep 1
        #value=$(cat /tmp/unsquashfs.log | grep -Eo --color=never " [0-9]*%" | sed -e "s|[^0-9]||g" | tail -n1)
        value=$(tail -n10 /tmp/unsquashfs.log | grep -Eo --color=never " [0-9]*%" | sed -e "s|[^0-9]||g" | tail -n1)
        if [[ ${value} =~ ${isnumber} ]]; then
            c=${value}
            echo ${c}
            echo "###"
            echo "${c} %"
            echo "###"
        else
            echo "###"
            echo "Progress Indicator Frozen at ${c} % (but no errors seen)"
            echo "###"
        fi
done
) |
DIALOG --gauge "${3}" 6 75 0

    while [ -e /tmp/setup-unsquashfs-running ]
    do
        echo "Won the race, night night (This should have been impossible)"
        sleep 1
    done
    if ! [ -f /tmp/.unsquashfs-retcode ]; then
        echo "This shouldn't be possible, /tmp/.unsquashfs-retcode is missing"
    fi
    # alert the user to fatal errors
    #make sure we have a retcode
    if [ -z "$(cat /tmp/.unsquashfs-retcode)" ]; then
        killall unsquashfs
        DIALOG --title "Error unsquashing, no return code" --exit-label \
        "OK" --textbox "/tmp/unsquashfs.log" 18 70
        return 1
    fi
    #make sure the retcode is a number
    if ! [[ $(cat /tmp/.unsquashfs-retcode) =~ ${isnumber} ]]; then
        killall unsquashfs
        DIALOG --title "Error unsquashing, code \"$(cat /tmp/.unsquashfs-retcode)\"" --exit-label \
        "OK" --textbox "/tmp/unsquashfs.log" 18 70
        return 1
    fi
    #make sure the retcode is 0
    if [ $(cat /tmp/.unsquashfs-retcode) -ne 0 ]; then
        killall unsquashfs
        DIALOG --title "Error unsquashing, code \"$(cat /tmp/.unsquashfs-retcode)\"" --exit-label \
        "OK" --textbox "/tmp/unsquashfs.log" 18 70
        return 1
    fi

    # save unsquashfs.log
    mv "/tmp/unsquashfs.log" "/tmp/unsquashfs-$(basename $1).log"
}


# do_rsync()
# does the rsync
#
# params: none
# returns: 1 on error
do_rsync() {
    mountpoint -q "${DESTDIR}"
    if [ $? -ne 0 ]; then
        DIALOG --msgbox "${DESTDIR} is not mounted, please re-run step 1" 0 0
        return 1
    fi
    run_unsquashfs /mnt/cdrom/image.squashfs ${DESTDIR} "Uncompressing base system"
    if [ $? -ne 0 ]; then
        DIALOG --msgbox "Failed to install base system" 0 0
        return 1
    fi

    for module in $(ls /mnt/cdrom/modules/*.lzm)
    do
        run_unsquashfs "${module}" "${DESTDIR}" "Uncompressing ${module%.lzm}"
        if [ $? -ne 0 ]; then
            DIALOG --msgbox "Failed to install portage" 0 0
            return 1
        fi
    done

    DIALOG --defaultno --yesno "Would you like to sync unsaved changes to your new install?  All modules are automatically \
	synced, but saying yes to this question will also sync changes made during this session which have not been saved \
        with flushchanges or makemo. Say no, and only a small set of essentials will be synced; say yes, and everything will be \
        synced, but it may take much longer." 0 0 \
	&& SYNC_ALL=1

    if [ "${SYNC_ALL}" = "1" ]; then
        rsync -av --progress --exclude=/mnt --exclude=/proc --exclude=/dev --exclude=/sys --exclude=/run /* ${DESTDIR}/ 2>&1 \
          | tee $LOG \
          | awk -f /usr/share/pentoo/rsync.awk \
          | sed --unbuffered 's/\([0-9]*\).*/\1/' \
          | dialog --title "Rsyncing / to new install" --gauge "Syncing /..." 6 75
        if [ $? -ne 0 ]; then
            DIALOG --msgbox "Failed to rsync /. See the log output for more information" 0 0
            return 1
        fi
    else
        rsync -av --progress /etc/* ${DESTDIR}/etc/ 2>&1 \
          | tee $LOG \
          | awk -f /usr/share/pentoo/rsync.awk \
          | sed --unbuffered 's/\([0-9]*\).*/\1/' \
          | dialog --title "Copying /etc/ folders." --gauge "Copying etc..." 6 75
        if [ $? -ne 0 ]; then
            DIALOG --msgbox "Failed to rsync /etc. See the log output for more information" 0 0
            return 1
        fi

        rsync -av --progress --exclude=/root/.bashrc /root/* ${DESTDIR}/root/ 2>&1 \
          | tee $LOG \
          | awk -f /usr/share/pentoo/rsync.awk \
          | sed --unbuffered 's/\([0-9]*\).*/\1/' \
          | dialog --title "Copying /root/ folders." --gauge "Copying home..." 6 75
        if [ $? -ne 0 ]; then
            DIALOG --msgbox "Failed to rsync the /root. See the log output for more information" 0 0
            return 1
        fi

        rsync -av --progress /lib/modules/$(uname -r)/* ${DESTDIR}/lib/modules/$(uname -r)/ 2>&1 \
          | tee $LOG \
          | awk -f /usr/share/pentoo/rsync.awk \
          | sed --unbuffered 's/\([0-9]*\).*/\1/' \
          | dialog --title "Rsyncing kernel modules" --gauge "Rsyncing /lib/modules/$(uname -r)..." 6 75
        if [ $? -ne 0 ]; then
            DIALOG --msgbox "Failed to rsync /lib/modules/$(uname -r)/. See the log output for more information" 0 0
            return 1
        fi
    fi

    sed -i '/aufs bindist livecd/d' ${DESTDIR}/etc/portage/make.conf
    chroot_mount
    chroot ${DESTDIR} emerge -C app-misc/livecd-tools pentoo/pentoo-livecd pentoo/pentoo-installer
    chroot_umount
    mknod -m666 ${DESTDIR}/dev/zero c 1 5
    mknod -m666 ${DESTDIR}/dev/null c 1 3
    mknod -m600 ${DESTDIR}/dev/console c 5 1
    mkdir -m755 ${DESTDIR}/media/{cd,dvd,fl}

    S_SELECT=1
}

# set_profile
# allows to choose a new profile in the DESTDIR env
# parameters: none
set_profile() {
    chroot_mount
    options=()
    CUR_PROF_TYPE=""
    CUR_PROF_NUM=""
    CUR_PROF="`chroot ${DESTDIR} eselect profile show | grep pentoo | awk '{match($1,"pentoo/.*",a)}END{print a[0]}'`"

    if [[ -n "`echo $CUR_PROF | grep hardened`" ]]; then
        CUR_PROF_TYPE="hardened"
    elif [[ -n "`echo $CUR_PROF | grep default`" ]]; then
        CUR_PROF_TYPE="default"
    else
        DIALOG --keep-tite --msgbox "Warning: unable to detect a current Pentoo profile in the $DESTDIR directory" 0 0
    fi

    while read -r line; do
        #grab all pentoo profiles
        if [[ $line == *pentoo* ]]; then
            #parse profiles based on the current type
            if [ "$CUR_PROF_TYPE" == "hardened" ]; then
                PROF="`echo $line | awk '{match($2,"pentoo/hardened/.*",a)}END{print a[0]}'`"
            elif [ "$CUR_PROF_TYPE" == "default" ]; then
                PROF="`echo $line | awk '{match($2,"pentoo/default/.*",a)}END{print a[0]}'`"
            fi
            #skip if the type is not current
            if [[ -z $PROF ]]; then
                continue
            fi
            #detect its profile number
            PROF_NUM="`echo $line | awk '{match($1,"[0-9]+",a)}END{print a[0]}'`"
            #generate options menu
            options+=($PROF_NUM $PROF)
            #find current profile number
            if [[ $PROF == $CUR_PROF ]]; then
                CUR_PROF_NUM="$PROF_NUM"
            fi
        fi
    done < <(chroot ${DESTDIR} eselect profile list)

    cmd=(dialog --keep-tite  --default-item "$CUR_PROF_NUM" --menu "Select profile:" 22 76 16)
    NEW_PROF_NUM=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)

    chroot ${DESTDIR} eselect profile set $NEW_PROF_NUM
    chroot_umount
}

# auto_fstab()
# preprocess fstab file
# comments out old fields and inserts new ones
# according to partitioning/formatting stage
#
auto_fstab()
{
    if [ "$S_MKFS" = "1" -o "$S_MKFSAUTO" = "1" ]; then
        if [ -f /tmp/.fstab ]; then
            # comment out anything not commented out
            sed -r -i 's/^[^#]/#&/' "${DESTDIR}/etc/fstab"
            # append entries from new configuration
            sort /tmp/.fstab >>$DESTDIR/etc/fstab
            sed -i -e '/aufs/d' $DESTDIR/etc/fstab
        fi
    fi
}

# auto_dmcrypt()
# copy dmcrypt and keys to partitions
#
auto_dmcrypt()
{
    chroot_mount
    if [ -f /tmp/.dmcrypt ]; then
        cat /tmp/.dmcrypt >> $DESTDIR/etc/conf.d/dmcrypt
        mkdir -p ${DESTDIR}/etc/keys
        for x in `cat /tmp/.dmcrypt | grep -e 'key=' | sed -e 's/:gpg//' -e's/.$//'`
        do
            cp /tmp/`basename ${x}` ${DESTDIR}/etc/keys/
        done
        chroot ${DESTDIR} /bin/bash <<EOF
rc-update add dmcrypt boot
EOF

    fi
    if [ ${S_FDE} = 1 ]; then
        cp /tmp/root.asc ${DESTDIR}/boot/key.gpg
    fi
    chroot_umount
}

# douefigrub()
# writes kernel to UEFI as new boot option
# parameters:
#     kernelpath: path to kernel, relative to partition root
#     initrdpath: path to initrd
#     bootparams: other boot params for kernel
# returns: 1 on failure
douefigrub() {
    # check if grub2 is installed
    grub2-mkimage -? 2>/dev/null 1>&2
    if [ $? -ne 0 ]; then
        DIALOG --msgbox "Error: Couldn't find grub2-mkimage.  Is GRUB-2 installed?" 0 0
        return 1
    fi
    local kernelpath="${1}"
    local initrdpath="${2}"
    local bootparams="${3}"
    # uefipart: uefi partition, ex. /dev/sda1
    DIALOG --menu "Select the partition to use as UEFI boot partition" 21 50 13 NONE - $PARTS 2>$ANSWER || return 1
    local uefipart=$(cat $ANSWER)
    PARTS="$(echo $PARTS | sed -e "s#${uefipart}\ _##g")"
    [ "$uefipart" = "NONE" ] && return 1
    # grubpart: grub partition, ex. (hd0,2)
    DIALOG --inputbox "Verify your GRUB device path" 8 65 "(hd0,2)" 2>$ANSWER || return 1
    local grubpart=$(cat $ANSWER)
    # uefimount: uefi partition mount point, ex. /boot
    local uefimount="$(mount | grep "^${uefipart} " | cut -d' ' -f 3)"
    # mount if not mounted
    if [ "${uefimount}" = "" ]; then
        mkdir -p /tmp/efibootpart || return 1
        mount "${uefipart}" /tmp/efibootpart || return 1
        uefimount=/tmp/efibootpart
    fi
    # safety check for /EFI/BOOT/BOOTX64.EFI (case insensitive for fat)
    local findefi="$(find "${uefimount}" -iwholename "${uefimount}/efi/boot/bootx64.efi")"
    if [ "${findefi}" != "" ]; then
        DIALOG --msgbox "Error: ${findefi} exists, refusing to overwrite!" 0 0
        return 1
    fi
    # safety check for /boot/grub2 (case insensitive for fat)
    local findgrub2="$(find "${uefimount}" -iwholename "${uefimount}/boot/grub2")"
    if [ "${findgrub2}" != "" ]; then
        DIALOG --msgbox "Error: ${findgrub2} exists, refusing to overwrite!" 0 0
        return 1
    fi
    # create grub image
    mkdir -p "${uefimount}/EFI/BOOT" || return 1
    grub2-mkimage -p /boot/grub2 -o "${uefimount}/EFI/BOOT/BOOTX64.EFI" -O x86_64-efi part_msdos part_gpt fat normal \
        || return 1
    # copy grub modules
    mkdir -p "${uefimount}/boot/grub2" || return 1
    cp -ar /usr/lib/grub/x86_64-efi "${uefimount}/boot/grub2/" \
        || return 1
    # create a crude grug.cfg
    mkdir -p "${uefimount}/boot/grub2" || return 1
    cat >> "${uefimount}/boot/grub2/grub.cfg" <<EOF
timeout=5
menuentry 'Pentoo' {
    insmod efi_gop
    insmod efi_uga
    insmod part_msdos
    insmod part_gpt
    root=${grubpart}
    linux ${kernelpath} ${bootparams}
    initrd ${initrdpath}
}
EOF
    DIALOG --msgbox "UEFI boot image successfully installed. You can now review the GRUB-2 config file." 0 0
    [ "$EDITOR" ] || seteditor
    $EDITOR "${uefimount}/boot/grub2/grub.cfg"
    DIALOG --msgbox "Success: UEFI booting by GRUB-2 installed!" 0 0
}

# douefi()
# writes kernel to UEFI as new boot option
# parameters:
#     kernelpath: path to kernel, relative to partition root
#     initrdpath: path to initrd
#     bootparams: other boot params for kernel
# returns: 1 on failure
#
douefi() {
    modprobe efivars
    # check if booted through UEFI
    efibootmgr -v 2>/dev/null 1>&2
    if [ $? -ne 0 ]; then
        DIALOG --msgbox "Error: Couldn't read from UEFI. Did you boot through UEFI?" 0 0
        return 1
    fi
    # kernel path with \\ instead of /
    local kernelpath=${1//\//\\\\}
    # initrd path with \ instead of /
    local initrdpath=${2//\//\\}
    local bootparams="${3}"
    # kernelpart: kernel partition, ex. /dev/sda2
    DIALOG --menu "Select the partition with the kernel (/boot)" 21 50 13 NONE - $PARTS 2>$ANSWER || return 1
    local kernelpart=$(cat $ANSWER)
    PARTS="$(echo $PARTS | sed -e "s#${kernelpart}\ _##g")"
    [ "$kernelpart" = "NONE" ] && return 1
    # kernelpart as disk and trailing part-number
    local kernelpartnu=$(expr match "${kernelpart}" '.*\([1-9][0-9]*\)')
    local kernelpartdisk=${kernelpart:0: -${#kernelpartnu}}
    # write to UEFI
    echo "${bootparams} initrd=${initrdpath}" | \
        iconv -f ascii -t ucs2 | \
        efibootmgr --create --gpt \
            --disk "${kernelpartdisk}" --part "${kernelpartnu}" \
            --label "Pentoo" \
            --loader "${kernelpath}" \
            --append-binary-args -
    if [ $? -ne 0 ]; then
        DIALOG --msgbox "Error: Couldn't write to UEFI!" 0 0
        return 1
    fi
    DIALOG --msgbox "Success: Direct UEFI booting installed!" 0 0
}

# dobootloader()
# installs boot loader
# parameters:
#     bootmode:
#         - uefigrub: installs GRUB2 UEFI-image plus menu
#         - uefi: boot kernel direclty by UEFI
# returns: 1 on failure
#
dobootloader() {
    local bootmode="${1}"
    local _kernver=$(getkernelversion)
    local kernelpath="/boot/kernel-genkernel${_kernver}"
    local initrdpath="/boot/initramfs-genkernel${_kernver}"
    local bootparams="root=/dev/ram0 real_root=${PART_ROOT}"
    # select UEFI boot partition
    PARTS=$(findpartitions _)
    # compose boot parameters
    # parse kernel cmdline (only video mode for now)
    for _var in $(cat /proc/cmdline); do
        case $_var in
            video=*)
                eval $(echo $_var) ;;
        esac
    done
    bootparams+=" video=${video} console=tty0 usbcore.autosuspend=1 net.ifnames=0 ro"
    case "${bootmode}" in
        uefigrub)
            douefigrub "${kernelpath}" "${initrdpath}" "${bootparams}" \
                || return 1
            ;;
        uefi)
            douefi "${kernelpath}" "${initrdpath}" "${bootparams}" \
            || return 1
            ;;
    esac
}

# dogrub()
# installs grub
# params: none
# returns: 1 on failure
dogrub() {
    get_grub_map
    local grubmenu="$DESTDIR/boot/grub/grub.conf"
    rm ${DESTDIR}/boot/grub/menu.lst
    ln -s ./grub.conf ${DESTDIR}/boot/grub/menu.lst
    if [ ! -f $grubmenu ]; then
        DIALOG --msgbox "Error: Couldn't find $grubmenu.  Is GRUB installed?" 0 0
        return 1
    fi
    # try to auto-configure GRUB...
    if [ "$PART_ROOT" != "" -a "$S_GRUB" != "1" ]; then
        grubdev=$(mapdev $PART_ROOT)
        local _rootpart="${PART_ROOT}"
        # look for a separately-mounted /boot partition
        bootdev=$(mount | grep $DESTDIR/boot | cut -d' ' -f 1)
        if [ "$grubdev" != "" -o "$bootdev" != "" ]; then
            subdir=
            if [ "$bootdev" != "" ]; then
                grubdev=$(mapdev $bootdev)
            else
                subdir="/boot"
            fi
            # keep the file from being completely bogus
            if [ "$grubdev" = "DEVICE NOT FOUND" ]; then
                DIALOG --msgbox "Your root boot device could not be autodetected by setup.  Ensure you adjust the 'root (hd0,0)' line in your GRUB config accordingly." 0 0
                grubdev="(hd0,0)"
            fi
            # remove default entries
            sed -i 's/^#splashimage/splashimage/' $grubmenu
            sed -i '/^#/d' $grubmenu
	        # parse kernel cmdline (only video mode for now)
	        for _var in $(cat /proc/cmdline)
	        do
			    case $_var in
				    video=*)
				    eval $(echo $_var)
				    ;;
			    esac
		    done
	        # get kernel version
	        local _kernver=$(getkernelversion)
            if [ ${S_FDE} = 1 ]; then
                cat >>$grubmenu <<EOF

# (0) Pentoo
title  Pentoo
root   $grubdev
kernel $subdir/kernel-genkernel${_kernver} root=/dev/ram0 real_root=/dev/mapper/root dogpg crypt_root=${_rootpart} root_key=/key.gpg root_keydev=${bootdev} ${_cmdline} video=${video} console=tty1 net.ifnames=0 ro
initrd $subdir/initramfs-genkernel${_kernver}

# (2) Windows
#title Windows
#rootnoverify (hd0,0)
#makeactive
#chainloader +1
EOF
            else
                cat >>$grubmenu <<EOF

# (0) Pentoo
title  Pentoo
root   $grubdev
kernel $subdir/kernel-genkernel${_kernver} root=/dev/ram0 real_root=${_rootpart} ${_cmdline} video=${video} console=tty1 net.ifnames=0 ro
initrd $subdir/initramfs-genkernel${_kernver}

# (2) Windows
#title Windows
#rootnoverify (hd0,0)
#makeactive
#chainloader +1
EOF
            fi
        fi
    fi

    DIALOG --msgbox "Before installing GRUB, you must review the configuration file.  You will now be put into the editor.  After you save your changes and exit the editor, you can install GRUB." 0 0
    [ "$EDITOR" ] || seteditor
    $EDITOR $grubmenu

    DEVS=$(finddisks _)
    DEVS="$DEVS $(findpartitions _)"
    if [ "$DEVS" = "" ]; then
        DIALOG --msgbox "No hard drives were found" 0 0
        return 1
    fi
    DIALOG --menu "Select the boot device where the GRUB bootloader will be installed (usually the MBR and not a partition)." 14 55 7 $DEVS 2>$ANSWER || return 1
    ROOTDEV=$(cat $ANSWER)
    DIALOG --infobox "Installing the GRUB bootloader..." 0 0
    if [ -d "${DESTDIR}"/usr/lib/grub/i386-pc ]; then
        cp -a "${DESTDIR}"/usr/lib/grub/i386-pc/* "${DESTDIR}"/boot/grub/
    fi
    sync
    # freeze xfs filesystems to enable grub installation on xfs filesystems
    if [ -x /usr/sbin/xfs_freeze ]; then
        mount | grep $DESTDIR/boot | grep -q xfs && /usr/sbin/xfs_freeze -f $DESTDIR/boot > /dev/null 2>&1
        mount | grep $DESTDIR | grep -q xfs && /usr/sbin/xfs_freeze -f $DESTDIR/ > /dev/null 2>&1
    fi
    # look for a separately-mounted /boot partition
    bootpart=$(mount | grep $DESTDIR/boot | cut -d' ' -f 1)
    if [ "$bootpart" = "" ]; then
        if [ "$PART_ROOT" = "" ]; then
            DIALOG --inputbox "Enter the full path to your root device" 8 65 "/dev/sda3" 2>$ANSWER || return 1
            bootpart=$(cat $ANSWER)
        else
            bootpart=$PART_ROOT
        fi
    fi
    DIALOG --defaultno --yesno "Do you have your system installed on software raid?\nAnswer 'YES' to install grub to another hard disk." 0 0
    if [ $? -eq 0 ]; then
        DIALOG --menu "Please select the boot partition device, this cannot be autodetected!\nPlease redo grub installation for all partitions you need it!" 14 55 7 $DEVS 2>$ANSWER || return 1
        bootpart=$(cat $ANSWER)
    fi
    bootpart=$(mapdev $bootpart)
    bootdev=$(mapdev $ROOTDEV)
    if [ "$bootpart" = "" ]; then
        DIALOG --msgbox "Error: Missing/Invalid root device: $bootpart" 0 0
        return 1
    fi
    if [ "$bootpart" = "DEVICE NOT FOUND" -o "$bootdev" = "DEVICE NOT FOUND" ]; then
        DIALOG --msgbox "GRUB root and setup devices could not be auto-located.  You will need to manually run the GRUB shell to install a bootloader." 0 0
        return 1
    fi
    /sbin/grub-install --no-floppy --recheck --grub-shell=$DESTDIR/sbin/grub --root-directory=$DESTDIR $ROOTDEV >/tmp/grub.log 2>&1
    cat /tmp/grub.log >$LOG
    # unfreeze xfs filesystems
    if [ -x /usr/sbin/xfs_freeze ]; then
        mount | grep $DESTDIR/boot | grep -q xfs && /usr/sbin/xfs_freeze -u $DESTDIR/boot > /dev/null 2>&1
        mount | grep $DESTDIR/boot | grep -q xfs && /usr/sbin/xfs_freeze -u $DESTDIR/ > /dev/null 2>&1
    fi

    if grep "Error [0-9]*: " /tmp/grub.log >/dev/null; then
        DIALOG --msgbox "Error installing GRUB. (see $LOG for output)" 0 0
        return 1
    fi
    DIALOG --msgbox "GRUB was successfully installed." 0 0
    S_GRUB=1
}

# set_clock()
# prompts user to set hardware clock and timezone
#
# params: none
# returns: 1 on failure
set_clock()
{
    # utc or local?
    DIALOG --menu "Is your hardware clock in UTC or local time?" 10 50 2 \
        "UTC" " " \
        "local" " " \
        2>$ANSWER || return 1
    HARDWARECLOCK=$(cat $ANSWER)

    # timezone?
    tzselect > $ANSWER || return 1
    TIMEZONE=$(cat $ANSWER)

    # set system clock from hwclock - stolen from rc.sysinit
    local HWCLOCK_PARAMS=""
    if [ "$HARDWARECLOCK" = "UTC" ]; then
        HWCLOCK_PARAMS="$HWCLOCK_PARAMS --utc"
    else
        HWCLOCK_PARAMS="$HWCLOCK_PARAMS --localtime"
    fi
    if [ "$TIMEZONE" != "" -a -e "/usr/share/zoneinfo/$TIMEZONE" ]; then
        /bin/rm -f /etc/localtime
        /bin/cp "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
    fi
    /sbin/hwclock --hctosys $HWCLOCK_PARAMS --noadjfile

    # display and ask to set date/time
    dialog --calendar "Set the date.\nUse <TAB> to navigate and arrow keys to change values." 0 0 0 0 0 2> $ANSWER || return 1
    local _date="$(cat $ANSWER)"
    dialog --timebox "Set the time.\nUse <TAB> to navigate and up/down to change values." 0 0 2> $ANSWER || return 1
    local _time="$(cat $ANSWER)"
    echo "date: $_date time: $_time" >$LOG

    # save the time
    # DD/MM/YYYY hh:mm:ss -> YYYY-MM-DD hh:mm:ss
    local _datetime="$(echo "$_date" "$_time" | sed 's#\(..\)/\(..\)/\(....\) \(..\):\(..\):\(..\)#\3-\2-\1 \4:\5:\6#g')"
    echo "setting date to: $_datetime" >$LOG
    date -s "$_datetime" 2>&1 >$LOG
    /sbin/hwclock --systohc $HWCLOCK_PARAMS --noadjfile

    S_CLOCK=1
}

prepare_harddrive()
{
    S_MKFSAUTO=0
    S_MKFS=0
    DONE=0
    local CURRENT_SELECTION=""
    while [ "$DONE" = "0" ]; do
        if [ -n "$CURRENT_SELECTION" ]; then
            DEFAULT="--default-item $CURRENT_SELECTION"
        else
            DEFAULT=""
        fi
        DIALOG $DEFAULT --menu "Prepare Hard Drive" 12 60 5 \
            "1" "Auto-Prepare (erases the ENTIRE hard drive)" \
            "2" "Manually Partition Hard Drives (WARNING: /etc/fstab will be broken, do not pick this option)" \
            "4" "Return to Main Menu" 2>$ANSWER
        CURRENT_SELECTION="$(cat $ANSWER)"
        case $(cat $ANSWER) in
            "1")
                autoprepare && DONE=1;;
            "2")
                partition && PARTFINISH="" 
		mountpoints && DONE=1;;
            *)
                DONE=1 ;;
        esac
    done
}

configure_system()
{
    # must mount chroot so pre/post installs don't fail out
    chroot_mount
    chroot $DESTDIR /bin/bash <<EOF
rc-update del autoconfig default
rc-update del binary-driver-handler
rc-update del firmware boot
rc-update del fixinittab default
rc-update add keymaps default
rc-update add fcron default
mv /etc/inittab.old /etc/inittab
mv /etc/init.d/halt.sh.orig /etc/init.d/halt.sh
EOF
    # don't need chroot anymore

    # ensure the disk is synced
    sync

    # automagic time!
    # any automatic configuration should go here
    DIALOG --infobox "Writing base configuration..." 6 40
    auto_fstab
    auto_dmcrypt

    [ "$EDITOR" ] || seteditor

    local CURRENT_SELECTION=""
    while true; do
        if [ -n "$CURRENT_SELECTION" ]; then
            DEFAULT="--default-item $CURRENT_SELECTION"
        else
            DEFAULT=""
        fi
        DIALOG $DEFAULT --menu "Configuration" 17 70 10 \
            "/etc/conf.d/keymaps"        "Keymap" \
            "/etc/fstab"                "Filesystem Mountpoints" \
            "/etc/resolv.conf"          "DNS Servers" \
            "/etc/hosts"                "Network Hosts" \
            "/etc/locale.gen"           "Glibc Locales" \
            "Root-Password"             "Set the root password" \
            "add-user"                  "Add a new user" \
            "Return"        "Return to Main Menu" 2>$ANSWER || CURRENT_SELECTION="Return"
        CURRENT_SELECTION="$(cat $ANSWER)"

        if [ "$CURRENT_SELECTION" = "Return" -o -z "$CURRENT_SELECTION" ]; then       # exit
            break
        elif [ "$CURRENT_SELECTION" = "Root-Password" ]; then            # non-file
#            while true; do
#                chroot ${DESTDIR} passwd root && break
#            done
		DIALOG $DEFAULT --clear --insecure --passwordbox "Enter a password" 17 70 2>$ANSWER
			local _rootpass=$(cat $ANSWER)
			chroot $DESTDIR /bin/bash <<EOF
echo -e "${_rootpass}\n${_rootpass}" | passwd root
EOF
			shred $ANSWER
			_rootpass=""
	elif [ "$CURRENT_SELECTION" = "add-user" ]; then
		DIALOG $DEFAULT --inputbox "Enter a username" 17 70 2>$ANSWER
			local _username=$(cat $ANSWER)
		DIALOG $DEFAULT --clear --insecure --passwordbox "Enter a password" 17 70 2>$ANSWER
			_userpass=$(cat $ANSWER)
#run passwd (the second line) just in case if user exists (as in rc1.9)
			chroot $DESTDIR /bin/bash <<EOF
useradd -p ${_userpass} -m -G users,wheel,audio,cdrom,video,cdrw,usb,plugdev,wireshark,kismet,android ${_username}
echo -e "${_userpass}\n${_userpass}" | passwd ${_username}
EOF
			shred $ANSWER
			_userpass=""
			rsync -r --exclude=.svn --exclude=.subversion "${DESTDIR}"/root/.[!.]* "${DESTDIR}"/home/"${_username}"/ >$LOG
			chroot ${DESTDIR} chown -R ${_username}:${_username} /home/${_username} >$LOG
#		while true; do
#			chroot ${DESTDIR} passwd $_username && break
#		done
        else                                                #regular file
            $EDITOR ${DESTDIR}${CURRENT_SELECTION}
        fi
    done

    ## POSTPROCESSING ##

    # /etc/locale.gen
    #
    chroot ${DESTDIR} locale-gen >$LOG
    chroot_umount
    # /etc/localtime
    cp /etc/localtime ${DESDIR}/etc/localtime >$LOG

    ## END POSTPROCESSING ##
    sync
    S_CONFIG=1
}

install_bootloader()
{
    DIALOG --menu "Which bootloader would you like to use?  Grub is the Pentoo default.\n\n" \
        14 80 7 \
        "GRUB" "Use the GRUB bootloader (default)" \
        "UEFI-GRUB" "Use GRUB2 and UEFI (unsupported)" \
        "UEFI" "Boot kernel directly by UEFI (unsupported)" \
        "None" "WARNING: you must install your own bootloader!" 2>$ANSWER
    case $(cat $ANSWER) in
        "GRUB") dogrub ;;
        "UEFI-GRUB") dobootloader 'uefigrub' ;;
        "UEFI") dobootloader 'uefi' ;;
    esac
}

mainmenu()
{
    if [ -n "$CURRENT_SELECTION" ]; then
        DEFAULT="--default-item $CURRENT_SELECTION"
    else
        DEFAULT=""
    fi
    DIALOG $DEFAULT --title " MAIN MENU " \
        --menu "Use the UP and DOWN arrows to navigate menus.  Use TAB to switch between buttons and ENTER to select." 16 55 8 \
        "0" "Set Clock" \
        "1" "Prepare Hard Drive" \
        "2" "Copy the Distribution" \
        "3" "Select Profile" \
        "4" "Configure System" \
        "5" "Install Bootloader" \
        "6" "Exit Install" 2>$ANSWER
    CURRENT_SELECTION="$(cat $ANSWER)"
    case $(cat $ANSWER) in
        "0")
            set_clock ;;
        "1")
            prepare_harddrive ;;
        "2")
            do_rsync ;;
        "3")
            set_profile ;;
        "4")
            configure_system ;;
        "5")
            install_bootloader ;;
        "6")
            echo ""
            echo "If the install finished successfully, you can now type 'reboot'"
            echo "to restart the system."
            echo ""
            exit 0 ;;
        *)
            DIALOG --yesno "Abort Installation?" 6 40 && exit 0
            ;;
    esac
}

#####################
## begin execution ##

RAMSIZE=$(awk '/MemTotal/ {printf( "%.0f\n", int ( $2 / 1024 ) + 1)}' /proc/meminfo)
if [ "$RAMSIZE" -le "1500" ]; then
	show_dialog --msgbox "The Pentoo Installer requires a minimum of 1.5GB of RAM to run. Failing safe." 0 0
	exit 1
fi

# display welcome txt depending on used dialog
WHICHDIALOG="$(get_dialog)"
show_dialog --textbox "${SHAREDIR}/welcome.${WHICHDIALOG}.txt" 0 0 || exit $?

while true; do
    mainmenu
done

exit 0

# vim: set ts=4 sw=4 et:
